//#################################### dx7.lib #########################################
// Yamaha DX7 emulation library. Its official prefix is `dx`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/dx7.lib>
//########################################################################################
// Yamaha DX7 emulation library. The various functions available in this library
// are used by the libraries generated from `.syx` DX7 preset files. This
// toolkit was greatly inspired by the CSOUND DX7 emulation package:
// <http://www.parnasse.com/dx72csnd.shtml>.
//
// This library and its related tools are under development. Use it at your
// own risk!
//##############################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

/*
TODO:
  * Fix any "todo:" in this file
  * Fix or better justify hard-coded values related to feedback.
*/

ba = library("basics.lib");
en = library("envelopes.lib");
ma = library("maths.lib");
os = library("oscillators.lib");
no = library("noises.lib");
it = library("interpolators.lib");

declare version "2.0.0";

//----------------------`(dx.)dx7_ampf`--------------------------
// DX7 amplitude conversion function. 3 versions of this function
// are available:
//
// * `dx7_amp_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_amp_func`: estimated mathematical equivalent of `dx7_amp_bpf`
// * `dx7_ampf`: default (sugar for `dx7_amp_func`)
//
// #### Usage:
//
// ```
// dx7AmpPreset : dx7_ampf_bpf : _
// ```
//
// Where:
//
// * `dx7AmpPreset`: DX7 amplitude value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F2 in the CSOUND implementation.
dx7_amp_bpf = ba.bpf.start(0,0) : seq(i,14,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,1)
with {
  xPoints(n) = ba.take(n+1,(9,19,29,39,49,59,64,69,74,79,84,89,94,98));
  yPoints(n) = ba.take(n+1,(0.000227445,0.000985595,0.002350265,0.005989386,0.014253222,0.033813495,0.052312358,0.080970432,0.124260804,0.190447309,0.295223654,0.457088704,0.70227445,1));
};
dx7_amp_func = min(99, max(0, _))/99 : pow(_,8);
dx7_ampf = dx7_amp_func;

//----------------------`(dx.)dx7_egraterisef`--------------------------
// DX7 envelope generator rise conversion function. 3 versions of this function
// are available:
//
// * `dx7_egraterise_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_egraterise_func`: estimated mathematical equivalent of `dx7_egraterise_bpf`
// * `dx7_egraterisef`: default (sugar for `dx7_egraterise_func`)
//
// #### Usage:
//
// ```
// dx7envelopeRise : dx7_egraterisef : _
// ```
//
// Where:
//
// * `dx7envelopeRise`: DX7 envelope rise value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F4 in the CSOUND implementation.
dx7_egraterise_bpf = ba.bpf.start(0,38) : seq(i,24,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,0.003)
with {
  xPoints(n) = ba.take(n+1,(4,9,14,19,24,29,34,42,45,48,51,54,60,66,68,71,74,77,
    80,83,86,89,92,95));
  yPoints(n) = ba.take(n+1,(22.8,12,7.5,4.8,2.7,1.8,1.3,.737,.615,
    .505,.409,.321,.080,.055,.032,.024,.018,.014,.011,.008,.008,
    .007,.005,.003));
};
// Function estimated from the CSOUND function (default)
dx7_egraterise_func = 38*pow((127-_)/127,12) : max(0.003);
dx7_egraterisef = dx7_egraterise_func;

//----------------------`(dx.)dx7_egraterisepercf`--------------------------
// DX7 envelope generator percussive rise conversion function. 3 versions of
// this function are available:
//
// * `dx7_egrateriseperc_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_egrateriseperc_func`: estimated mathematical equivalent of `dx7_egrateriseperc_bpf`
// * `dx7_egraterisepercf`: default (sugar for `dx7_egrateriseperc_func`)
//
// #### Usage:
//
// ```
// dx7envelopePercRise : dx7_egraterisepercf : _
// ```
//
// Where:
//
// * `dx7envelopePercRise`: DX7 envelope percussive rise value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F5 in the CSOUND implementation.
dx7_egrateriseperc_bpf = ba.bpf.start(0,0.00001) : seq(i,10,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,1)
with {
  xPoints(n) = ba.take(n+1,(30,34,39,49,59,69,79,89,94,98));
  yPoints(n) = ba.take(n+1,(0.00001,0.02,0.06,0.14,0.24,0.35,0.5,0.7,0.86,1));
};
// Function estimated from the CSOUND function (default)
dx7_egrateriseperc_func = >=(30)*min(_-30,68)/68 : pow(_,1.8);
dx7_egraterisepercf = dx7_egrateriseperc_func;

//----------------------`(dx.)dx7_egratedecayf`--------------------------
// DX7 envelope generator decay conversion function. 3 versions of
// this function are available:
//
// * `dx7_egratedecay_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_egratedecay_func`: estimated mathematical equivalent of `dx7_egratedecay_bpf`
// * `dx7_egratedecayf`: default (sugar for `dx7_egratedecay_func`)
//
// #### Usage:
//
// ```
// dx7envelopeDecay : dx7_egratedecayf : _
// ```
//
// Where:
//
// * `dx7envelopeDecay`: DX7 envelope decay value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F6 in the CSOUND implementation.
dx7_egratedecay_bpf = ba.bpf.start(0,318) : seq(i,23,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,.008)
with {
  xPoints(n) = ba.take(n+1,(3,7,12,17,22,27,32,40,43,49,52,55,58,63,66,69,72,75,
    78,81,84,87,90));
  yPoints(n) = ba.take(n+1,(181,115,63,39.7,20,11.2,7,5.66,3.98,1.99,
    1.34,.99,.71,.41,.15,.081,.068,.047,.037,.025,.02,.013,.008));
};
// Function estimated from the CSOUND function (default)
dx7_egratedecay_func = 318*pow((127-_)/127,12.6) : max(0.008);
dx7_egratedecayf = dx7_egratedecay_func;

//----------------------`(dx.)dx7_egratedecaypercf`--------------------------
// DX7 envelope generator percussive decay conversion function. 3 versions of
// this function are available:
//
// * `dx7_egratedecayperc_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_egratedecayperc_func`: estimated mathematical equivalent of `dx7_egratedecayperc_bpf`
// * `dx7_egratedecaypercf`: default (sugar for `dx7_egratedecayperc_func`)
//
// #### Usage:
//
// ```
// dx7envelopePercDecay : dx7_egratedecaypercf : _
// ```
//
// Where:
//
// * `dx7envelopePercDecay`: DX7 envelope decay value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F7 in the CSOUND implementation.
dx7_egratedecayperc_bpf = ba.bpf.start(0,0.00001) : seq(i,10,ba.bpf.point(xPoints(i),yPoints(i))) : ba.bpf.end(127,1)
with {
  xPoints(n) = ba.take(n+1,(10,20,30,40,50,60,70,80,90,99));
  yPoints(n) = ba.take(n+1,(0.25,0.35,0.43,0.52,0.59,0.7,0.77,0.84,0.92,1));
};
// Function estimated from the CSOUND function (default)
dx7_egratedecayperc_func = min(99)/99 : pow(_,0.7);
dx7_egratedecaypercf = dx7_egratedecayperc_func;

//----------------------`(dx.)dx7_eglv2peakf`--------------------------
// DX7 envelope level to peak conversion function. 3 versions of
// this function are available:
//
// * `dx7_eglv2peak_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_eglv2peak_func`: estimated mathematical equivalent of `dx7_eglv2peak_bpf`
// * `dx7_eglv2peakf`: default (sugar for `dx7_eglv2peak_func`)
//
// #### Usage:
//
// ```
// dx7Level : dx7_eglv2peakf : _
// ```
//
// Where:
//
// * `dx7Level`: DX7 level value (0-99)
//-----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F8 in the CSOUND implementation.
dx7_eglv2peak_bpf = ba.bpf.start(0,0) : seq(i,14,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,2.08795)
with {
  xPoints(n) = ba.take(n+1,(9,19,29,39,49,59,64,59,74,79,84,89,94,98));
  yPoints(n) = ba.take(n+1,(0.000477,0.002,0.00493,0.01257,0.02992,0.07098,0.10981,0.16997,0.260855,0.39979,0.61974,0.95954,1.47425,2.08795));
};
// Function estimated from the CSOUND function (default)
dx7_eglv2peak_func = min(98)/98 : pow(_,8) : *(2.08795);
dx7_eglv2peakf = dx7_eglv2peak_func;

//----------------------`(dx.)dx7_fdbkscalef`--------------------------
// DX7 feedback scaling conversion function.
//
// #### Usage:
//
// ```
// dx7Feedback  : dx7_fdbkscalef : _
// ```
//
// Where:
//
// * `dx7Feedback`: DX7 feedback value
//-----------------------------------------------------------
// Corresponds to F11 in the CSOUND implementation
dx7_fdbkscalef = *(0.875);

//------------------------------`(dx.)dx7_op`---------------------------
// DX7 Operator. Implements a phase-modulable sine wave oscillator connected
// to a DX7 envelope generator.
//
// #### Usage:
//
// ```
// dx7_op(mode,freqCoarse,freqFine,detune,outLev,R1,R2,R3,R4,L1,L2,L3,L4,keyVelSens,ampModSens,rateScale,lfoWave,lfoSpeed,lfoDelay,lfoPMD,lfoAMD,lfoSync,lfoPitchModSens,oscKeySync,pitch_egR1,pitch_egR2,pitch_egR3,pitch_egR4,pitch_egL1,pitch_egL2,pitch_egL3,pitch_egL4,breakpoint,breakpointLDepth,breakpointRDepth,breakpointLCurve,breakpointRCurve,transpose,phaseMod,type,base_freq,gain,gate) : _
// ```
//
// Where:
//
// * `mode`: pitch mode (0=ratio; 1=fixed)
// * `freqCoarse`: coarse frequency (0-31)
// * `freqFine`: fine frequency (0-99)
// * `detune`: detune in semitones (-7 - 7)
// * `outLev`: output level (0-99)
// * `R1`: envelope rate 1 (0-99)
// * `R2`: envelope rate 2 (0-99)
// * `R3`: envelope rate 3 (0-99)
// * `R4`: envelope rate 4 (0-99)
// * `L1`: envelope level 1 (0-99)
// * `L2`: envelope level 2 (0-99)
// * `L3`: envelope level 3 (0-99)
// * `L4`: envelope level 4 (0-99)
// * `keyVelSens`: key velocity sensitivity (0-7)
// * `ampModSens`: amplitude sensitivity (0-3)
// * `rateScale`: envelope rate scale (0-7)
// * `breakpoint`: break point position (0-99)
// * `breakpointLDepth`: break point left depth (0-99)
// * `breakpointRDepth`: break point right depth (0-99)
// * `breakpointLCurve`: break point left curve (0-3) (-LIN,-EXP,+EXP,+LIN)
// * `breakpointRCurve`: break point right curve (0-3) (-LIN,-EXP,+EXP,+LIN)
// * `lfoWave`: LFO wave mode (0-5) (triangle, saw down, saw up, square, sine, sample&hold)
// * `lfoSpeed`: LFO speed (0-99)
// * `lfoDelay`: LFO delay (0-99)
// * `lfoPMD`: LFO pitch modulation depth (0-99)
// * `lfoAMD`: LFO amplitude modulation depth (0-99)
// * `lfoSync`: (0-1) (0=no retrigger; 1=retrigger)
// * `lfoPitchModSens`: LFO Pitch modulation sensitivity (0-7)
// * `oscKeySync`: osc key sync (0-1)
// * `pitch_egR1`: pitch envelope generator rate 1 (0-99)
// * `pitch_egR2`: pitch envelope generator rate 2 (0-99)
// * `pitch_egR3`: pitch envelope generator rate 3 (0-99)
// * `pitch_egR4`: pitch envelope generator rate 4 (0-99)
// * `pitch_egL1`: pitch envelope generator level 1 (0-99)
// * `pitch_egL2`: pitch envelope generator level 2 (0-99)
// * `pitch_egL3`: pitch envelope generator level 3 (0-99)
// * `pitch_egL4`: pitch envelope generator level 4 (0-99)
// * `transpose`: global transpose (-24 - 24)
// * `phaseMod`: phase deviation (-1 - 1)
// * `type`: operator type (0-1)
// * `base_freq`: frequency of the oscillator
// * `gain`: general gain
// * `gate`: trigger signal
//-----------------------------------------------------------------
dx7_op(mode,freqCoarse,freqFine,detune,outLev,R1,R2,R3,R4,L1,L2,L3,L4,keyVelSens,ampModSens,rateScale,breakpoint,breakpointLDepth,breakpointRDepth,breakpointLCurve,breakpointRCurve,lfoWave,lfoSpeed,lfoDelay,lfoPMD,lfoAMD,lfoSync,lfoPitchModSens,oscKeySync,pitch_egR1,pitch_egR2,pitch_egR3,pitch_egR4,pitch_egL1,pitch_egL2,pitch_egL3,pitch_egL4,transpose,phaseMod,type,base_freq,gain,gate) = output
with {

  freq = select2(mode,freq_ratio*base_freq*ba.semi2ratio(transpose+detune+lfoDetune+pitchEnvDetune),freq_fixed) // todo: check this
  with {
    freq_ratio = rdtable(FreqTableCoarse_ratio, freqCoarse)*rdtable(FreqTableFine_ratio, freqFine);
    freq_fixed = rdtable(FreqTableCoarse_fixed, freqCoarse)*rdtable(FreqTableFine_fixed, freqFine);

    FreqTableCoarse_ratio = waveform{
      0.5,1,2,3,4,5,6,7,8,9,10,11,12,13,
      14,15,16,17,18,19,20,21,22,23,24,
      25,26,27,28,29,30,31
    };

    FreqTableCoarse_fixed = waveform{
      1,10,100,1000,
      1,10,100,1000,
      1,10,100,1000,
      1,10,100,1000,
      1,10,100,1000,
      1,10,100,1000,
      1,10,100,1000,
      1,10,100,1000
    };

    FreqTableFine_ratio = waveform{
    1.00,1.01,1.02,1.03,1.04,1.05,1.06,
      1.07,1.08,1.09,1.10,1.11,1.12,1.13,
      1.14,1.15,1.16,1.17,1.18,1.19,1.20,
      1.21,1.22,1.23,1.24,1.25,1.26,1.27,
      1.28,1.29,1.30,1.31,1.32,1.33,1.34,
      1.35,1.36,1.37,1.38,1.39,1.40,1.41,
      1.42,1.43,1.44,1.45,1.46,1.47,1.48,
      1.49,1.50,1.51,1.52,1.53,1.54,1.55,
      1.56,1.57,1.58,1.59,1.60,1.61,1.62,
      1.63,1.64,1.65,1.66,1.67,1.68,1.69,
      1.70,1.71,1.72,1.73,1.74,1.75,1.76,
      1.77,1.78,1.79,1.80,1.81,1.82,1.83,
      1.84,1.85,1.86,1.87,1.88,1.89,1.90,
      1.91,1.92,1.93,1.94,1.95,1.96,1.97,
      1.98,1.99
    };

    FreqTableFine_fixed = waveform{
      1.000,1.023,1.047,1.072,1.096,1.122,
      1.148,1.175,1.202,1.230,1.259,1.288,
      1.318,1.349,1.380,1.413,1.445,1.479,
      1.514,1.549,1.585,1.622,1.660,1.698,
      1.738,1.778,1.820,1.862,1.905,1.950,
      1.995,2.042,2.089,2.138,2.188,2.239,
      2.291,2.344,2.399,2.455,2.512,2.570,
      2.630,2.692,2.716,2.818,2.884,2.951,
      3.020,3.090,3.162,3.236,3.311,3.388,
      3.467,3.548,3.631,3.715,3.802,3.890,
      3.981,4.074,4.169,4.266,4.365,4.467,
      4.571,4.677,4.786,4.898,5.012,5.129,
      5.248,5.370,5.495,5.623,5.754,5.888,
      6.026,6.166,6.310,6.457,6.607,6.761,
      6.918,7.079,7.244,7.413,7.586,7.762,
      7.943,8.128,8.318,8.511,8.718,8.913,
      9.120,9.333,9.550,9.772
    };
  };

  tablesize = 1 << 16;
  
  // todo: the interaction between lfoDelay and lfoSync is ambiguous.
  lfo = lfo_tri, lfo_sawdown, lfo_sawup, lfo_square, lfo_sine, lfo_sh : ba.selectn(6, lfoWave)
  with {
    lfoTableSize = 1 << 16;

    hold_timer = 1 : (+~(*(ba.if(gate-gate',0,1))));

    lfoFreq = lfoSpeed : pow(_/99, 4) : it.remap(0, 1, 1, 50); // todo: remap to "under 1 hz to about 50 Hz" according to official DX7 manual.
    phasor = os.hsp_phasor(lfoTableSize,lfoFreq,phasor_reset,0.5)
    with {
      lfoDelaySamples = lfoDelay * (.5 * ma.SR / 99); // todo: don't know how to scale, so set max to 0.5 seconds
      phasor_reset = (lfoDelaySamples >= hold_timer) | (lfoSync & (ba.impulsify(gate)));
    };

    lfo_tri = rdtable(lfoTableSize, triwaveform, ma.modulo(phasor+int(lfoTableSize/4), lfoTableSize))
    with {
      triwaveform = 2*abs((ba.period(lfoTableSize)*2/lfoTableSize-1))-1;
    };
    lfo_sawdown = -1*lfo_sawup;
    lfo_sawup = (phasor/lfoTableSize)*2-1;
    lfo_square = select2(phasor < (lfoTableSize/2),-1,1); // todo: not sure about phase
    lfo_sine = 0-rdtable(lfoTableSize, os.sinwaveform(lfoTableSize), phasor);
    lfo_sh = no.lfnoise0(lfoFreq); // "random output" according to official DX7 manual
  };

  lfoDetune = lfo * lfoPMD * lfoPitchModSens * (12 / (99*7)); // todo: it currently detunes to plus/minus 12 semitones when lfoPMD is maxed at 99 and lfoPitchModSens is 7

  lfoGain = it.interpolate_linear(lfoAMD*ampModSens/(99*3), 0, lfo*49); // todo:

  // phase modulation, not freq modulation
  sineWave = rdtable(tablesize, os.sinwaveform(tablesize), idx)
  with {
    idx = ma.modulo(int(os.hs_phasor(tablesize,freq, oscKeySync & (ba.impulsify(gate))) + phaseMod*tablesize),tablesize);
  };

  pitchEnvDetune = makeEnvelope(pitch_egR1,pitch_egR2,pitch_egR3,pitch_egR4,pitch_egL1,pitch_egL2,pitch_egL3,pitch_egL4) : (ba.bpf.start(0,-48) : ba.bpf.point(50,0) : ba.bpf.end(99,48));

  makeEnvelope(r1,r2,r3,r4,egl1,egl2,egl3,egl4) = en.dx7envelope(egr1,egr2,egr3,egr4,egl1,egl2,egl3,egl4,gate)
  with {
    // computing rates
    rs = (base_freq : ba.hz2midikey)-21 : /(105)*6*rateScale; // todo:
    egr1 = r1+rs : min(99) <:
      select2(egl1 > egl4,dx7_egratedecayf,dx7_egraterisef) <:
      *(egl4 <: select2( egl1 > egl4, dx7_egratedecaypercf, dx7_egraterisepercf)),
      *(egl1 <: select2( egl1 > egl4, dx7_egratedecaypercf, dx7_egraterisepercf)) :
      - : abs : max(0.001);
    egr2 = r2+rs : min(99) <:
      select2(egl2 > egl1,dx7_egratedecayf,dx7_egraterisef) <:
      *(egl1 <: select2( egl2 > egl1, dx7_egratedecaypercf, dx7_egraterisepercf)),
      *(egl2 <: select2( egl2 > egl1, dx7_egratedecaypercf, dx7_egraterisepercf)) :
      - : abs : max(0.001);
    egr3 = r3+rs : min(99) <:
      select2(egl3 > egl2,dx7_egratedecayf,dx7_egraterisef) <:
      *(egl2 <: select2( egl3 > egl2, dx7_egratedecaypercf, dx7_egraterisepercf)),
      *(egl3 <: select2( egl3 > egl2, dx7_egratedecaypercf, dx7_egraterisepercf)) :
      - : abs : max(0.001);
    egr4 = r4+rs : min(99) <:
      select2(egl4 >= egl3,dx7_egratedecayf,dx7_egraterisef) <:
      *(egl3 <: select2(egl4 >= egl3, dx7_egratedecaypercf, dx7_egraterisepercf)),
      *(egl4 <: select2(egl4 >= egl3, dx7_egratedecaypercf, dx7_egraterisepercf)) :
      - : abs : max(0.001);
  };

  brkPointGain = brkDepth*select2((brkCurve == 1)|(brkCurve==2), normalized, pow(normalized, 2.)) // todo: exponential is not pow
  with {
    note = base_freq : ba.hz2midikey;
    breakpointNote = breakpoint : it.remap(0, 99, 33, 108); // A1 (33) to C8 (108)
    is_right_sec = note >= breakpointNote;

    brkCurve = select2(is_right_sec, breakpointLCurve, breakpointRCurve);
    brkDepth = select2(is_right_sec, breakpointLDepth, breakpointRDepth)*select2(brkCurve<2,1,-1);

    // A1 (33) to C8 (108)
    normalized = select2(is_right_sec, (breakpoint-note)/max(1, breakpointNote-33), (note-breakpoint)/max(1, 108-breakpointNote)) : min(1);
  };
  
  envGain = makeEnvelope(R1,R2,R3,R4,L1,L2,L3,L4) + (outLev-99) + brkPointGain + lfoGain <: select2(type,dx7_eglv2peakf,dx7_ampf);
  velGain = it.interpolate_linear(keyVelSens/7, 1, gain);
  output = envGain*velGain*sineWave;
};

//------------------------------`(dx.)dx7_all`---------------------------
// Generic DX7 function where all parameters are controllable using UI elements.
// The `master-with-mute` branch must be used for this function to work...
// This function is MIDI-compatible.
//
// #### Usage
//
// ```
// dx7_all : _
// ```
//-----------------------------------------------------------------
dx7_all = par(i,32,dx7_algorithm(i+1) : control(algorithm-1 == i)) :> _
with {
    algorithm = nentry("h:DX7/v:Global/h:Main/Algorithm", 1, 1, 32, 1);
};

//------------------------------`(dx.)dx7_algorithm`---------------------------
// DX7 function for a specific algorithm at compile-time. This function is 
// MIDI-compatible.
//
// #### Usage
//
// ```
// dx7_algorithm(algorithm) : _
// ```
// 
// Where:
// * `algorithm`: algorithm identifier (1-32)
//
//-----------------------------------------------------------------
dx7_algorithm(algorithm) = hgroup("DX7", dx7_algo(algorithm))
with {

  GLOBAL(x) = vgroup("Global", x);
  MAIN(x) = GLOBAL(hgroup("[0] Main", x));
  PEGR(x) = GLOBAL(hgroup("[1] Pitch Env Generator Rates", x));
  PEGL(x) = GLOBAL(hgroup("[2] Pitch Env Generator Levels", x));
  LFO(x) = GLOBAL(hgroup("[3] LFO", x));
  freq = GLOBAL(hslider("[4] freq",400,50,1000,0.01));
  gain = GLOBAL(hslider("[5] gain",0.8,0,1,0.01));
  gate = GLOBAL(button("[6] gate"));

  feedback = MAIN(hslider("[0] Feedback [style:knob]",0,0,7,1) : dx7_fdbkscalef/(2*ma.PI));
  transpose = MAIN(hslider("[1] Transpose [style:knob]",0,-24,24,1));
  oscKeySync = MAIN(hslider("[2] Osc Key Sync [style:knob]",1,0,1,1));

  pegR1 = PEGR(hslider("[0] R1 [style:knob]",90,0,99,1));
  pegR2 = PEGR(hslider("[1] R2 [style:knob]",90,0,99,1));
  pegR3 = PEGR(hslider("[2] R3 [style:knob]",90,0,99,1));
  pegR4 = PEGR(hslider("[3] R4 [style:knob]",90,0,99,1));

  pegL1 = PEGL(hslider("[0] L1 [style:knob]",50,0,99,1));
  pegL2 = PEGL(hslider("[1] L2 [style:knob]",50,0,99,1));
  pegL3 = PEGL(hslider("[2] L3 [style:knob]",50,0,99,1));
  pegL4 = PEGL(hslider("[3] L4 [style:knob]",50,0,99,1));

  lfoWave = LFO(nentry("[0] Wave [style:menu{'Triangle':0;'Saw Down':1;'Saw Up':2;'Square':3;'Sine':4;'Sample & Hold':5}]",0,0,5,1));
  lfoSpeed = LFO(hslider("[1] Speed [style:knob]",35,0,99,1));
  lfoDelay = LFO(hslider("[2] Delay [style:knob]",0,0,99,1));
  lfoPMD = LFO(hslider("[3] PMD [style:knob]",0,0,99,1));
  lfoAMD = LFO(hslider("[4] AMD [style:knob]",0,0,99,1));
  lfoSync = LFO(hslider("[5] Sync [style:knob]",1,0,1,1));
  lfoPitchModSens = LFO(hslider("[6] Pitch Mod Sens [style:knob]",3,0,7,1));

  // concise way of making the same UI element for all 6 operators.
  oppar(entry, n) = ba.take(n+1, par(i, 6, func(i)))
  with {
    func(i) = vgroup("[%i]Operator %j", entry)
    with {
      j = i+1;
    };
  };

  AEG(x) = vgroup("[0] Amp Env Generator", x);
  RATES(x) = AEG(hgroup("[0] Rates", x));
  LEVELS(x) = AEG(hgroup("[1] Levels", x));
  AEOTHER(x) = AEG(hgroup("[2] Other", x));
  TONE(x) = hgroup("[1] Tone", x);
  BREAKPOINT(x) = hgroup("[2] Break Point", x);

  // Each of these is a `getSomeParameterForOperator(i)` for i [0-5]
  egR1           = oppar(RATES(hslider("[0] R1 [style:knob]",90,0,99,1)));
  egR2           = oppar(RATES(hslider("[1] R2 [style:knob]",90,0,99,1)));
  egR3           = oppar(RATES(hslider("[2] R3 [style:knob]",90,0,99,1)));
  egR4           = oppar(RATES(hslider("[3] R4 [style:knob]",90,0,99,1)));
  egL1           = oppar(LEVELS(hslider("[0] L1 [style:knob]",90,0,99,1)));
  egL2           = oppar(LEVELS(hslider("[1] L2 [style:knob]",90,0,99,1)));
  egL3           = oppar(LEVELS(hslider("[2] L3 [style:knob]",90,0,99,1)));
  egL4           = oppar(LEVELS(hslider("[3] L4 [style:knob]",0,0,99,1)));
  freqMode       = oppar(AEOTHER(hslider("[0] Freq Mode [style:knob]",0,0,1,1)));
  rateScale      = oppar(AEOTHER(hslider("[1] Rate Scale [style:knob]",0,0,7,1)));
  outLevel       = oppar(AEOTHER(hslider("[2] Level [style:knob]",99,0,99,1)));
  keyVelSens     = oppar(AEOTHER(hslider("[3] KeyVelSens [style:knob]",7,0,7,1)));
  ampModSens     = oppar(AEOTHER(hslider("[4] AmpModSens [style:knob]",0,0,3,1)));

  freqCoarse     = oppar(TONE(nentry("[0] Freq Coarse",1,0.0,31,1)));
  freqFine       = oppar(TONE(nentry("[1] Freq Fine",0,0.0,99,1)));
  detune         = oppar(TONE(hslider("[2] Detune [style:knob]",0,-7,7,1)));

  breakpoint       = oppar(BREAKPOINT(hslider("[0] Break Point [style:knob]", 51, 0, 99, 1)));  // todo: not sure about default
  breakpointLDepth = oppar(BREAKPOINT(hslider("[1] Left Depth [style:knob]", 0, 0, 99, 1)));
  breakpointRDepth = oppar(BREAKPOINT(hslider("[2] Right Depth [style:knob]", 0, 0, 99, 1)));
  breakpointLCurve = oppar(BREAKPOINT(nentry("[3] Left Curve [style:menu{'-LIN':0;'-EXP':1;'+EXP':2;'+LIN':3}]",0,0,3,1)));
  breakpointRCurve = oppar(BREAKPOINT(nentry("[4] Right Curve [style:menu{'-LIN':0;'-EXP':1;'+EXP':2;'+LIN':3}]",0,0,3,1)));

  make_dx7_op(i, phase_mod, type) = dx7_op(
    freqMode(i),freqCoarse(i),freqFine(i),detune(i),outLevel(i),
    egR1(i),egR2(i),egR3(i),egR4(i),egL1(i),egL2(i),egL3(i),egL4(i),
    keyVelSens(i),ampModSens(i),rateScale(i),
    breakpoint(i),breakpointLDepth(i),breakpointRDepth(i),breakpointLCurve(i),breakpointRCurve(i),
    lfoWave,lfoSpeed,lfoDelay,lfoPMD,lfoAMD,lfoSync,lfoPitchModSens,
    oscKeySync,
    pegR1,pegR2,pegR3,pegR4,pegL1,pegL2,pegL3,pegL4,
    transpose,phase_mod,type,freq,gain,gate
  );
  
  // NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(1) = (op2 : op1),(op6~*(feedback*.2) : op5 : op4 : op3) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, _, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(2) = (op2~*(feedback*.2) : op1),(op6 : op5 : op4 : op3) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, _, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // Note: weird rand and delay implemented in the csound orchestra and not really sure why...
  dx7_algo(3) = (op3 : op2 : op1),(op6~*(feedback) : op5 : op4) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, 0, 1);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(4) = (op3 : op2 : op1),(op6 : op5 : op4)~*(feedback) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, 0, 1);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .1 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(5) = (op2 : op1),(op4 : op3),(op6~*(feedback*.1) : op5) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(6) = (op2 : op1),(op4 : op3),(op6 : op5)~*(feedback) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(7) = (op2 : op1),(op4,(op6~*(feedback) : op5) :> op3) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .1 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(8) = (op2 : op1),(op4~*(feedback*.1),(op6 : op5) :> op3) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, _, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .4 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(9) = (op2~*(feedback*.4) : op1),(op4,(op6 : op5) :> op3) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(10) = (op5,op6 :> op4),(op3~*(feedback*.2) : op2 : op1) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, _, 1);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(11) = (op5,op6~*(feedback*.2) :> op4),(op3 : op2 : op1) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, 0, 1);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(12) = (op4,op5,op6 :> op3),(op2~*(feedback*.2) : op1) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(13) = (op4,op5,op6~*(feedback) :> op3),(op2 : op1) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(14) = (op2 : op1),(op5,op6~*(feedback) :> op4 : op3) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, _, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .4 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(15) = (op2~*(feedback*.4) : op1),(op5,op6 :> op4 : op3) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, _, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(16) = op2,(op4 : op3),(op6~*(feedback) : op5) :> op1
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 1);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .5 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(17) = op2~*(feedback*.5),(op4 : op3),(op6 : op5) :> op1
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 1);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(18) = op2,op3~*(feedback),(op6 : op5 : op4) :> op1
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, _, 1);
    op3 = make_dx7_op(2, _, 1);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .4 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(19) = (op3 : op2 : op1),(op6~*(feedback*.4) <: op4,op5) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, 0, 1);
    op2 = make_dx7_op(1, _, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(20) = (op3~*(feedback) <: op1,op2),(op5,op6 :> op4) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, _, 1);
    op2 = make_dx7_op(1, _, 0);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(21) = (op3~*(feedback) <: op1,op2),(op6 <: op4,op5) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, _, 1);
    op2 = make_dx7_op(1, _, 0);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .1 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(22) = (op2 : op1),(op6~*(feedback*.1) <: op3,op4,op5) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, _, 1);
    op2 = make_dx7_op(1, 0, 0);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(23) = op1,(op3 : op2),(op6~*(feedback) <: op4,op5) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, 0, 1);
    op2 = make_dx7_op(1, _, 0);
    op1 = make_dx7_op(0, _, 0);
  };

  // NOTE: the .6 for feedback was hardcoded in the csound orchestra, not sure why we need it
  dx7_algo(24) = op1,op2,(op6~*(feedback*.6) <: op3,op4,op5) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 0);
    op1 = make_dx7_op(0, 0, 0);
  };

  dx7_algo(25) = op1,op2,op3,(op6~*(feedback) <: op4,op5) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, 0, 0);
    op2 = make_dx7_op(1, 0, 0);
    op1 = make_dx7_op(0, 0, 0);
  };

  dx7_algo(26) = op1,(op3 : op2),(op5,op6~*(feedback) :> op4) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, 0, 1);
    op2 = make_dx7_op(1, _, 0);
    op1 = make_dx7_op(0, 0, 0);
  };

  dx7_algo(27) = op1,(op3~*(feedback) : op2),(op5,op6 :> op4) :> _
  with {
    op6 = make_dx7_op(5, 0, 1);
    op5 = make_dx7_op(4, 0, 1);
    op4 = make_dx7_op(3, _, 0);
    op3 = make_dx7_op(2, _, 1);
    op2 = make_dx7_op(1, _, 0);
    op1 = make_dx7_op(0, 0, 0);
  };

  dx7_algo(28) = (op2 : op1),(op5~*(feedback) : op4 : op3),op6 :> _
  with {
    op6 = make_dx7_op(5, 0, 0);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, _, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 1);
    op1 = make_dx7_op(0, _, 0);
  };

  dx7_algo(29) = op1,op2,(op4 : op3),(op6~*(feedback) : op5) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, 0, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 0);
    op1 = make_dx7_op(0, 0, 0);
  };

  dx7_algo(30) = op1,op2,(op5~*(feedback) : op4 : op3),op6 :> _
  with {
    op6 = make_dx7_op(5, 0, 0);
    op5 = make_dx7_op(4, _, 1);
    op4 = make_dx7_op(3, _, 1);
    op3 = make_dx7_op(2, _, 0);
    op2 = make_dx7_op(1, 0, 0);
    op1 = make_dx7_op(0, 0, 0);
  };

  dx7_algo(31) = op1,op2,op3,op4,(op6~*(feedback) : op5) :> _
  with {
    op6 = make_dx7_op(5, _, 1);
    op5 = make_dx7_op(4, _, 0);
    op4 = make_dx7_op(3, 0, 0);
    op3 = make_dx7_op(2, 0, 0);
    op2 = make_dx7_op(1, 0, 0);
    op1 = make_dx7_op(0, 0, 0);
  };

  dx7_algo(32) = op1,op2,op3,op4,op5,op6 :> _
  with {
    op6 = make_dx7_op(5, 0, 0);
    op5 = make_dx7_op(4, 0, 0);
    op4 = make_dx7_op(3, 0, 0);
    op3 = make_dx7_op(2, 0, 0);
    op2 = make_dx7_op(1, 0, 0);
    op1 = make_dx7_op(0, 0, 0);
  };

};
